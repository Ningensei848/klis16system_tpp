% [定理 １３] ----------------------------------------------------------;
% 〈メネラウス(Menelaus)の定理の証明〉
% △ABCの３辺BC, CA, ABまたはその延長が頂点を通らない１直線と交わる点を、
% それぞれP, Q, Rとする。 ※xy座標上で考え、１直線はx軸と一致していると想定する
% A(u1, u2) B(u3, u4) C(u5, u6)
% P(x1, 0) Q(x2, 0) R(x3, 0)
%----------------------------------------------------------------------;

% 関数定義読み込み） ----------------------------------------------------;
load_package groebner;
on comp,gcd,ezgcd;
off allfac,pwrds;

%----------------------------------------------------------------------;
% ２点間のユークリッド距離D^2 -----------------------------------------------;
procedure squared_euclid(a1,a2,b1,b2)$
begin
 scalar d;
 d:=(a1-b1)^2+(a2-b2)^2;
 return d
end$
%----------------------------------------------------------------------;


% ---------------------------------------------------------------------;
% ＜証明＞ -------------------------------------------------------------;

order x3, x2, x1, u6, u5, u4, u3, u2, u1;
factor x3, x2, x1;


%----------------------------------------------------------------------;
% 仮定 ----------------------------------------------------------------;

% A, B, Cから直線におろした垂線の足をAd(u1, 0), Bd(u3, 0), Cd(u5, 0)とすると、
% AAd // BBd // CCdだから、 BP:PC=BBd:CCd, CQ:QA=CCd:AAd, AR:RB=AAd:BBd
% これは、両辺を二乗しても同様のことが言える。

bp2:=squared_euclid(u3, u4, x1, 0);
pc2:=squared_euclid(x1, 0, u5, u6);
cq2:=squared_euclid(u5, u6, x2, 0);
qa2:=squared_euclid(x2, 0, u1, u2);
ar2:=squared_euclid(u1, u2, x3, 0);
rb2:=squared_euclid(x3, 0, u3, u4);

aad2:=squared_euclid(u1, u2, u1, 0);
bbd2:=squared_euclid(u3, u4, u3, 0);
ccd2:=squared_euclid(u5, u6, u5, 0);


% BP:PC=BBd:CCd より
h1:=bp2*ccd2-bbd2*pc2;

% CQ:QA=CCd:AAd より
h2:=cq2*aad2-ccd2*qa2;

% AR:RB=AAd:BBd より
h3:=ar2*bbd2-aad2*rb2;


%----------------------------------------------------------------------;
% 結論 ----------------------------------------------------------------;

%  BP     CQ     AR
% ---- ・ ---- ・ ---- = 1
%  PC     QA     RB          となる

conclusion:=bp2*cq2*ar2-pc2*qa2*rb2;


%----------------------------------------------------------------------;
% Groebner Basis: 結果が1となったら、仮定が誤っている可能性が高い ---------------;

%%% 変数を定義し、lex形式で並べる ------------------------------------------;
torder({x3, x2, x1}, lex)$

%%% 仮定において定義した式からGroebner Basisを求める -------------------------;
gb:=groebner{h1, h2, h3};

%---------------------------------------------------------;
% 「glterms」が出力するのは、グレブナー基底の計算過程で〈ゼロにはならない〉
% と仮定された式のリストである。
%---------------------------------------------------------;

%%% u に関する制約条件 --------------------------------------------------;
glterms;


%%% gbを法としてgを簡約 --------------------------------------------------;
preduce(conclusion, gb);

% ==> 0 になっていれば、定理は成立 ------------------------------------------;

showtime;

;end;