%----------------------------------------------------------------------;
% 〈三角形の内心の証明〉
% A(0, 0) B(u1, 0) C(u2, u3) の三点による三角形ABCを考える
% 内心を作図から求める手順に沿って証明してみる
%----------------------------------------------------------------------;

% ---------------------------------------------------------------------;
% ＜証明＞ -------------------------------------------------------------;

order x7, x6, x5,x4, x3, x2, x1, u8, u7, u6, u5, u4, u3, u2, u1;


factor x7, x6, x5, x4, x3, x2, x1;



% 関数定義読み込み（※ローカル環境へコピーしてきたもの） --------------------------;
in cal_sys_relations$




%----------------------------------------------------------------------;
% 仮定 ----------------------------------------------------------------;


% ---------------------------------------------------------------------;
% 直線CA上に、AB=AD となる点Dをとる -----------------------------------------;
% BDの中点をEとすると、△ABDは二等辺三角形だから、AE⊥BDとなる --------------------;
% DはCA上にあるのだから、共線となっている ( C-D-Aと考える ) -----------------------;
% また、EはBD上にあり、共線となっている ( B-E-Dと考える ) -------------------------;
% D(x1, u4) E(x2, u5)

h1:=requal(0, 0, u1, 0, 0, 0, x1, u4);


           2     2     2
h1 :=  - x1  - u4  + u1

h2:=midpoint(1, u1, 0, x2, u5, x1, u4);


h2 := 2*x2 - x1 - u1

h3:=midpoint(2, u1, 0, x2, u5, x1, u4);


h3 := 2*u5 - u4

h4:=vertically(0, 0, x2, u5, u1, 0, x1, u4);


h4 := x2*x1 - x2*u1 + u5*u4

h5:=collinear(u2, u3, x1, u4, 0, 0);


h5 :=  - x1*u3 + u4*u2

h6:=collinear(u1, 0, x2, u5, x1, u4);


h6 := x2*u4 - x1*u5 + u5*u1 - u4*u1




% ---------------------------------------------------------------------;
% 直線BC上に、BA=BF となる点Fをとる -----------------------------------------;
% FAの中点をGとすると、△BFAは二等辺三角形だから、BG⊥FAとなる --------------------;
% FはBC上にあるのだから、共線となっている ( B-F-Cと考える ) -----------------------;
% また、GはFA上にあり、共線となっている ( F-G-Aと考える ) -------------------------;
% F(x3, u6) G(x4, u7)

h7:=requal(u1, 0, 0, 0, u1, 0, x3, u6);


           2               2
h7 :=  - x3  + 2*x3*u1 - u6

h8:=midpoint(1, x3, u6, x4, u7, 0, 0);


h8 := 2*x4 - x3

h9:=midpoint(2, x3, u6, x4, u7, 0, 0);


h9 := 2*u7 - u6

h10:=vertically(u1, 0, x4, u7, x3, u6, 0, 0);


h10 :=  - x4*x3 + x3*u1 - u7*u6

h11:=collinear(u1, 0, x3, u6, u2, u3);


h11 := x3*u3 - u6*u2 + u6*u1 - u3*u1

h12:=collinear(x3, u6, x4, u7, 0, 0);


h12 :=  - x4*u6 + x3*u7





% 点IはAE上にあり、かつBG上にある (AEとBGの交点である) -------------------------;
% つまり、共線となっている ( A-I-E , B-I-G と考える)
% I(x6, u8)

h13:=collinear(0, 0, x6, u8, x3, u6);


h13 := x6*u6 - x3*u8

h14:=collinear(u1, 0, x6, u8, x4, u7);


h14 := x6*u7 - x4*u8 + u8*u1 - u7*u1




%----------------------------------------------------------------------;
% 結論 ----------------------------------------------------------------;
% 二角の二等分線が交わる点IはCH上にあり、共線となっている ( C-I-Hと考える ) --------;

i_conclusion:=collinear(u2, u3, x6, u8, x5, 0);


i_conclusion :=  - x6*u3 + x5*( - u8 + u3) + u8*u2


showtime;


Time: 0 ms  plus GC time: 20 ms



%----------------------------------------------------------------------;
% Groebner Basis: 結果が1となったら、仮定が誤っている可能性が高い ---------------;

%%% 変数を定義し、lex形式で並べる ------------------------------------------;
torder({x7, x6, x5, x4, x3, x2, x1}, lex)$



%%% 仮定において定義した式からGroebner Basisを求める -------------------------;
gb:=groebner{h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14};


gb := {1}


%---------------------------------------------------------;
% 「glterms」が出力するのは、グレブナー基底の計算過程で〈ゼロにはならない〉
% と仮定された式のリストである。
%---------------------------------------------------------;

%%% u に関する制約条件 --------------------------------------------------;
glterms;


{ - 2*u5 + u4,

 u3,

 u4,

  - 2*u7 + u6,

 u6,

 u7,

 u2,

  - u6*u2 + u6*u1 + u3*u1}



%%% gbを法としてgを簡約 --------------------------------------------------;
preduce(i_conclusion, gb);


0


% ==> 0 になっていれば、定理は成立 ------------------------------------------;


%-------------------------------------------------------------;
% first(list), second(list)はそれぞれリスト内の1つ目、2つ目の要素を返す
% solve(f, v) は, 関数f の変数をv の方程式としてみて解く
%-------------------------------------------------------------;

% X座標も求めてみる ------------------------------------------------------;
%solve(first(gb), x8);
%solve(second(gb), x7);
%----------------------------------------------------------------------;

showtime;


Time: 0 ms  plus GC time: 9 ms


;

end;