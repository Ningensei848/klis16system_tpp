%----------------------------------------------------------------------;
% 三角形ABCの各頂点と、向かい合う辺の中点を結ぶ3本の直線は1点Gで交わる
%----------------------------------------------------------------------;
% A(0, 0) B(u1, 0) C(u2, u3)
% D(x1, x2) E(x3, x4) F(x5, x6) G(x7, x8)

% ---------------------------------------------------------------------;
% ＜証明＞ -------------------------------------------------------------;

order x8, x7, x6, x5, x4, x3, x2, x1, u3, u2, u1;

factor x8, x7, x6, x5, x4, x3, x2, x1;

% 関数定義読み込み（※ローカル環境へコピーしてきたもの） --------------------------;
in cal_sys_relations$

%-------------------------------;
% midpoint(x,a1,a2,b1,b2,c1,c2);
% if x=1 then f:=2*b1-a1-c1
%        else f:=2*b2-a2-c2;
%-------------------------------;

%----------------------------------------------------------------------;
% 仮定 ----------------------------------------------------------------;


% D は AB の中点 ( A-D-B と考える ) --------------------------------------;

h1:=midpoint(1, 0, 0, x1, x2, u1, 0);
h2:=midpoint(2, 0, 0, x1, x2, u1, 0);

% E は BC の中点 ( B-E-C と考える ) --------------------------------------;

h3:=midpoint(1, u1, 0, x3, x4, u2, u3);
h4:=midpoint(2, u1, 0, x3, x4, u2, u3);

% F は CA の中点 ( C-F-A と考える ) --------------------------------------;

h5:=midpoint(1, u2, u3, x5, x6, 0, 0);
h6:=midpoint(2, u2, u3, x5, x6, 0, 0);

%-------------------------------------------;
% collinear(a1,a2,b1,b2,c1,c2)$
%        scalar a;
%        a:=(a1-b1)*(b2-c2)-(a2-b2)*(b1-c1);
%-------------------------------------------;

% A-G-E は一直線 ------------------------------------------------------;
h7:=collinear(0, 0, x7, x8, x3, x4);

% B-G-F は一直線 ------------------------------------------------------;
h8:=collinear(u1, 0, x7, x8, x5, x6);
% 結論
% C-G-D は一直線 ------------------------------------------------------;
g:=collinear(u2, u3, x7, x8, x1, x2);

showtime;


%----------------------------------------------------------------------;
% Groebner Basis: 結果が1となったら、仮定が誤っている可能性が高い ---------------;

%%% 変数を定義し、lex形式で並べる ------------------------------------------;
torder({x8, x7, x6, x5, x4, x3, x2, x1}, lex)$

%%% 仮定において定義した式からGroebner Basisを求める -------------------------;
gb:=groebner{h1, h2, h3, h4, h5, h6, h7, h8};

%---------------------------------------------------------;
% 「glterms」が出力するのは、グレブナー基底の計算過程で〈ゼロにはならない〉
% と仮定された式のリストである。
%---------------------------------------------------------;

%%% u に関する制約条件 --------------------------------------------------;
glterms;

%%% gbを法としてgを簡約 --------------------------------------------------;
preduce(g, gb);

% ==> 0 になっていれば、定理は成立 ------------------------------------------;

%-------------------------------------------------------------;
% first(list), second(list)はそれぞれリスト内の1つ目、2つ目の要素を返す
% solve(f, v) は, 関数f の変数をv の方程式としてみて解く
%-------------------------------------------------------------;


% G座標も求めてみる ------------------------------------------------------;
solve(first(gb), x8);
solve(second(gb), x7);

%----------------------------------------------------------------------;


showtime;

;end;