%----------------------------------------------------------------------;
% 三角形ABCの各頂点から、向かい合う辺に下ろした3本の垂線は1点V(垂心)で交わる
%----------------------------------------------------------------------;
% 三角形ABCを考える -----------------------------------------------------;
% A(0, 0) B(u1, 0) C(u2, u3)
% D(x1, x2) E(x3, x4) F(x5, x6)
% V(x7, x8)

% ---------------------------------------------------------------------;
% ＜証明＞ -------------------------------------------------------------;

% 出力時の変数の順序を定める宣言的記述 -------------------------------------;
order x8, x7, x6, x5, x4, x3, x2, x1, u3, u2, u1;

% 引数の順序には何の影響も与えないが、区切って出力させる宣言的記述 ----------------;
% その後の様々な操作をする際の前提としてこの宣言が必要になる場合がある --------------;
factor x8, x7, x6, x5, x4, x3, x2, x1;

% 関数定義読み込み（※ローカル環境へコピーした） -------------------------------;
in cal_sys_relations$


%----------------------------------------------------------------------;
% 仮定 ----------------------------------------------------------------;


%-------------------------------------------;
% 垂線: 直線ABと直線CDが垂直に交わるときの関数f
% vertically(a1,a2,b1,b2,c1,c2,d1,d2);
%        f:=(a1-b1)*(c1-d1)+(a2-b2)*(c2-d2);
%-------------------------------------------;

%-------------------------------------------;
% 共線: 直線AB上に点Cがあるときの関数f
% collinear(a1,a2,b1,b2,c1,c2)$
%       f:=(a1-b1)*(b2-c2)-(a2-b2)*(b1-c1);
%-------------------------------------------;


% D は 頂点Cから対辺ABに下ろした垂線の足 ( A-D-B と考える ) -------------------;
% A(0, 0) B(u1, 0) C(u2, u3) D(x1, x2)
% このとき、「AB ⊥ CD」 かつ 「A, D, Bは共線 collinear」である ------------------;

s1:=vertically(0, 0, u1, 0, u2, u3, x1, x2);
s2:=collinear(0, 0, x1, x2, u1, 0);


% E は 頂点Aから対辺BCに下ろした垂線の足 ( B-E-C と考える ) -------------------;
% A(0, 0) E(x3, x4) B(u1, 0) C(u2, u3)
% このとき、「AE ⊥ BC」 かつ 「C, F, Aは共線 collinear」である -------------------;

s3:=vertically(0, 0, x3, x4, u1, 0, u2, u3);
s4:=collinear(u1, 0, x3, x4, u2, u3);


% F は 頂点Bから対辺CAに下ろした垂線の足 ( C-F-A と考える ) -------------------;
% C(u2, u3) A(0, 0) B(u1, 0) F(x5, x6)
% このとき、「CA ⊥ BF」 かつ 「C, F, Aは共線 collinear」である -------------------;

s5:=vertically(u2, u3, 0, 0, u1, 0, x5, x6);
s6:=collinear(u2, u3, x5, x6, u2, u3);


% C-V-D は一直線 -------------------------------------------------------;
% C(u2, u3) V(x7, x8) D(x1, x2)

s7:=collinear(u2, u3, x7, x8, x1, x2);


% A-V-E は一直線 -------------------------------------------------------;
% A(0, 0) V(x7 ,x8) E(x3, x4)

s8:=collinear(0, 0, x7, x8, x3, x4);


%----------------------------------------------------------------------;
% 結論 ----------------------------------------------------------------;

% B-V-F は一直線 -------------------------------------------------------;
% B(u1, 0) V(x7, x8) F(x5, x6)

v_conclusion:=collinear(u1, 0, x7, x8, x5, x6);


showtime;


%----------------------------------------------------------------------;
% Groebner Basis: -----------------------------------------------------;

%%% 変数を定義し、lex形式で並べる ------------------------------------------;
torder({x8, x7, x6, x5, x4, x3, x2, x1}, lex)$

%%% 仮定において定義した式からGroebner Basisを求める -------------------------;
gb:=groebner{s1, s2, s3, s4, s5, s6, s7, s8};

%---------------------------------------------------------;
% 「glterms」が出力するのは、グレブナー基底の計算過程で〈ゼロにはならない〉
% と仮定された式のリストである。
%---------------------------------------------------------;

%%% u に関する制約条件 --------------------------------------------------;
glterms;

%%% gbを法としてv_conclusionを簡約 --------------------------------------------------;
preduce(v_conclusion, gb);

% ==> 0 になっていれば、定理は成立 ------------------------------------------;

%-------------------------------------------------------------;
% first(list), second(list)はそれぞれリスト内の1つ目、2つ目の要素を返す
% solve(f, v) は, 関数f の変数をv の方程式としてみて解く
%-------------------------------------------------------------;


% G座標も求めてみる ------------------------------------------------------;
solve(first(gb), x8);
solve(second(gb), x7);

%----------------------------------------------------------------------;


showtime;

;end;
